---
title: "R: Basic conceps"
output: html_document
---

# Змінні (аналог комірки в таблиці Excel)
Для того, щоб зберігати результат підрахунків або дані на різних етапах програми, використовують змінні. Створити змінну та надати їй якесь значення можна за допомогою
оператора `<-` (`=` теж працюватиме, але це стилістично неправильно в R).

Змінна може зберігати будь-яке значення: цифру, рядок тексту, таблицю, список таблиць, список списків списків таблиць.


## Найпростіші Типи даних у R
```{r}
# ціле число
int_var <- 1

# неціле число (з плаваючою точкою, ще називають "float")
double_var <- 1.25

# строки
char_var <- "це є строка"

# логічні значення
logic_var <- TRUE # or FALSE

# відсутність значення:
na_var <- NA
```

Завжди можна перевірити тип змінної
```{r}
typeof(char_var)   # з попереднього чанка коду

# НЕПРАВИЛЬНО:
typeof(char_var) == "character"    # >>> TRUE
# ПРАВИЛЬНО:
is.character(char_var)    # >>> TRUE

# перевірка на тип, функції починаються на "is."
is.integer(1)    # >>> TRUE
is.double(1)    # >>> FALSE
is.double(1.23)    # >>> TRUE
is.na(12.3)    # >>> FALSE, це важлива функція, дивитися чи є значення взагалі

# зведення до якогось типу, функції починаються на "as."
# наприклад, to integer:
as.integer(2.34)    # >>> 2
as.double("1.2")    # >>> 1.2 з строки створили число з плаваючою точкою

```


# Колекції значень. Вектори й списки
## Вектори
```{r}
v <-  c(1.2, 34.5, 13.1)    # функція c() створює вектор
v + 1:31    # додамо до вектора числа від 1 до 30. Вийде c(1.2+1, 34.5+2, 13.1+3, 1.2+4, 34.5+5, …)
v <- c(1:100)    # а так зробимо вектор від 1 до 100

# як отримати 51й елемент вектора, треба дати в [] його індекс: [51]
v[51]    # 51й елемент вектора

v[11:20]    # елементи вектора від 11-го до 20-го — slice

v[c(1, 5, 25)] # індекси також можуть бути вектором, напр. c(1, 5, 25) дістане перший, п'ятий та двадцять п'ятий елементи

v[c(T, F, F)]    # >>> 1   4   7  10  13  16  19  22  25  28

# Можемо використати вектор логічних значень, щоб фільтрувати інший вектор за умовою
# v %% 6 == 0    # >>> FALSE FALSE FALSE FALSE FALSE TRUE …
v[v %% 6 == 0]    # кратні 6-ти: "%%" — отримати остачу від ділення. Якщо вона нульова " == 0", значить число кратне 6.
```

### Операції з векторами
```{r}
# створюємо вектор із низкою числових значень, і присвоюєм його змінній 
price_in_hryvnya <- c(200, 300, 400, 5000, 1)  # тепер в price_in_hryvnya міститься 5 чисел

currency_ratio <- 25 # тут значення змінної дорівнює 28
price_in_usd <- price_in_hryvnya / currency_ratio  # векторизація! оператор ділення ("/") застосовується одразу до всіх елементів вектору!

price_in_usd
```

### Вектори із строками
```{r}
text_vector <- c("one", "two", "three")
text_vector[1]    # <<< "one"

# Додати до кожного елелмента вектора кілька рядків ("number", " ")
paste(text_vector, "number")
paste(text_vector, c("a", "b", "c", "d", "e"), sep="__my_sep__")
?paste    # у будь-якій незрозумілій ситуації читайте хелп

```

Вектори однорівневі: якщо дати вектору інші вектори, він їх об'єднає:
```{r}
c(c(1,    2 ,  3 ),
  c("a", "b", c("c", "d"))
)
```

Вектори можна робити іменованими:
```{r}
v <- c(a = 1, b = 2, c = 3)

# THE SAME AS:
v <- c(1, 2, 3)
names(v) <- c("a", "b", "c")

v
```


## Списки
1. Багатовимірні (recursive) — **завжди** містять інші списки (навіть коли ви цього не очікуєте).  
2. Як правило, іменовані  
```{r}
l <- list(1, 2, 3)
# Багатовимірні по дефолту: ми створили ніби-то одновимірний, плаский, список. Коли намагаємось взяти з нього перший елемент, пін повертає знову список, а не цифру 1.
typeof(l[1])    # <<< "list"

# Щоб отримати значення такого списку, треба виокристати подвійні квадратні дужки, l[[i]]:
typeof(l[[1]])    # <<< "double"

# Безкінечне НЕПРАВИЛЬНЕ діставання першого елемента зі списку, не робіть так!
l[1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1][1]    # ще раз, не треба так
# на виході все одно маємо список
```

### Іменовані списки
```{r}
l <- list(a = 1, b = 2, c = 3)
l[1]    # 1й елемент списку з іменем "a", у формі списку

l[[1]]    # 1й елемент списку з іменем "а", без імені

# Три способи дістати сам елемент, число в нашому випадку, зі списку
l$b
l[["b"]]
l[[2]]

# Дістати список з елементом і його іменем
l[3]
l["c"]
```

# Приклад ієрархічного списку і що таке [JSON](http://www.json.org/example.html)
```{r}
# так встановлюють додаткові пакети — сторонній код, який вміє щось робити. Пакет "jsonlite" вміє працювати з форматом JSON.
install.packages("jsonlite")
```

```{r}
# Імпортуємо пакет у наше робоче середовище
library("jsonlite")

# який це тип даних?
url = "https://declarations.com.ua/declaration/nacp_788c3a07-8d69-4cb8-93e5-9b7403b0540b?format=opendata"

json = read_json(url)    # читання даних, далі більше про це

names(json$declaration$unified_source)    # перелічимо імена елементів списку

vehicles = json$declaration$unified_source$step_4    # збережемо потрібну частину великого вкладеного списку для зручності

car <- paste(
  vehicles[[1]]$objectType,
  vehicles[[1]]$brand,
  vehicles[[1]]$model,
  vehicles[[1]]$graduationYear,
  sep = ", "
)    # яку машину купив Вакарчук?

print(car)
```
Додатково:  
[Чим же список відрізняється від вектора?](https://stackoverflow.com/questions/8594814/what-are-the-differences-between-vector-and-list-data-types-in-r)  
```{r}
v <- c("a", 1)

is.list(v)         # <<< FALSE
is.vector(v)       # <<< TRUE
is.atomic(v)       # <<< TRUE
is.recursive(v)    # <<< FALSE
```
У більшості мов програмування немає ділення на "списки" й "вектори". Натомість є ділення на іменовані та неіменовані колекції значень, на впорядковані й невпорядковані тощо. Ці структури даних в R часто критикують за заплутаність і нелогічність;).


# DataFrame — таблиця
```{r}
name <- c("Ira", "Vlad", "Tonya")   # перша колонка
age <- c(22, 21, 20)                # друга колонка
gender <- c("F", "M", NA)          # третя колонка

df <- data.frame(name, age, gender) # вся таблиця
df
```

## Як діставати елементи з датафрейма?
```{r}
# Значення 1го рядка, 2ї колонки
df[1, 2]

# 2га колонка
df[, 1]
# 1й рядок
df[1, ]

# Колонка "name"
df$name
# Ще один спосіб остримати колонку
df["age"]

# Перший рядок, колонка "age"
df[1, "age"]

# всі рядки людей старше 21 (включно)
df[df$age >= 21, ]    # зверніть увагу на кому

# Назви колонок
colnames(df)


```

# DRY (don't repeat yourself) — Цикли
Якщо потрібно зробити якусь дію декілька разів, використовуємо цикли
```
for(<довільна назва 1 елемента зі списка/вектора> in <сам список/вектор>){
  <що робити з кожним елементом>
}
```
```{r}
# надрукуємо "one", "two", "three"
for(i in c("one", "two", "three")){
  print(i)
}

```
Цикл виконається 3 рази. Щоразу значення "і" буде змінюватись всередині циклу

# if-else — розгалуження (як буде розвиватися логіка програми)
В залежності від істиності умови, виконуємо або один, або інший шматок коду

```{r}
b <- 1.3

if(b > 2){ # якби b було більшк 2, виконувати фрагмент коду, що в {}
  print("The number is too big")
} else { # інакше  виконувати цей код 
  print("The number is too small")
}
```
Частина з `else` необов'язкова. Ще може бути `else if`. https://www.datamentor.io/r-programming/if-else-statement/

# DRY — функції
Функція — це послідовність дій, яку зберегли, щоб далі використати.
Наприклад, вам дуже часто, в різних частинах коду, треба піднести число в квадрат і додати до нього 100. Щоб не повторювати один і той самий код, його можна записати у функцію.

Функція має:
- назву, за якою її потім викликають (`sqr_add_100` у прикладі нижче)
- аргументи — вхідні дані, з чим вона працює (`x`)
- результат — що вона поверне на виході (`return(…)`)

```{r}
sqr_add_100 <- function(x) {
  result <- x^2 + 100
  return(result)    # return не обов'язкове, функція поверне результат виконання останнього рядка
}

sqr_add_100(5)
```

Про те, як писати в R ефекивно, зрозуміло й гарно: https://style.tidyverse.org/files.html

